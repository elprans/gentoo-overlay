From 5e4d3b42e4ed502f27958f7923f479a488ee597c Mon Sep 17 00:00:00 2001
From: Elvis Pranskevichus <el@prans.net>
Date: Thu, 4 Feb 2010 20:25:12 -0500
Subject: [PATCH] Make dateutil 2to3 ready

---
 dateutil/easter.py        |    2 +-
 dateutil/parser.py        |   12 +++---
 dateutil/relativedelta.py |   12 +++---
 dateutil/rrule.py         |   62 +++++++++++++++++++-----------
 dateutil/tz.py            |   91 +++++++++++++++++++++------------------------
 example.py                |    4 +-
 setup.py                  |    5 ++
 test.py                   |   31 +++++++++++++--
 8 files changed, 127 insertions(+), 92 deletions(-)

diff --git a/dateutil/easter.py b/dateutil/easter.py
index d794410..afa1c08 100644
--- a/dateutil/easter.py
+++ b/dateutil/easter.py
@@ -52,7 +52,7 @@ def easter(year, method=EASTER_WESTERN):
     """
 
     if not (1 <= method <= 3):
-        raise ValueError, "invalid method"
+        raise ValueError("invalid method")
 
     # g - Golden year - 1
     # c - Century
diff --git a/dateutil/parser.py b/dateutil/parser.py
index 5d824e4..ee006b8 100644
--- a/dateutil/parser.py
+++ b/dateutil/parser.py
@@ -155,7 +155,7 @@ class _resultbase(object):
         for attr in self.__slots__:
             value = getattr(self, attr)
             if value is not None:
-                l.append("%s=%s" % (attr, `value`))
+                l.append("%s=%s" % (attr, repr(value)))
         return "%s(%s)" % (classname, ", ".join(l))
 
     def __repr__(self):
@@ -300,7 +300,7 @@ class parser(object):
                                                       second=0, microsecond=0)
         res = self._parse(timestr, **kwargs)
         if res is None:
-            raise ValueError, "unknown string format"
+            raise ValueError("unknown string format")
         repl = {}
         for attr in ["year", "month", "day", "hour",
                      "minute", "second", "microsecond"]:
@@ -311,8 +311,8 @@ class parser(object):
         if res.weekday is not None and not res.day:
             ret = ret+relativedelta.relativedelta(weekday=res.weekday)
         if not ignoretz:
-            if callable(tzinfos) or tzinfos and res.tzname in tzinfos:
-                if callable(tzinfos):
+            if hasattr(tzinfos, '__call__') or tzinfos and res.tzname in tzinfos:
+                if hasattr(tzinfos, '__call__'):
                     tzdata = tzinfos(res.tzname, res.tzoffset)
                 else:
                     tzdata = tzinfos.get(res.tzname)
@@ -323,8 +323,8 @@ class parser(object):
                 elif isinstance(tzdata, int):
                     tzinfo = tz.tzoffset(res.tzname, tzdata)
                 else:
-                    raise ValueError, "offset must be tzinfo subclass, " \
-                                      "tz string, or int offset"
+                    raise ValueError("offset must be tzinfo subclass, " \
+                                      "tz string, or int offset")
                 ret = ret.replace(tzinfo=tzinfo)
             elif res.tzname and res.tzname in time.tzname:
                 ret = ret.replace(tzinfo=tz.tzlocal())
diff --git a/dateutil/relativedelta.py b/dateutil/relativedelta.py
index 3327582..bf92714 100644
--- a/dateutil/relativedelta.py
+++ b/dateutil/relativedelta.py
@@ -115,7 +115,7 @@ Here is the behavior of operations with relativedelta:
         if dt1 and dt2:
             if not isinstance(dt1, datetime.date) or \
                not isinstance(dt2, datetime.date):
-                raise TypeError, "relativedelta only diffs datetime/date"
+                raise TypeError("relativedelta only diffs datetime/date")
             if type(dt1) is not type(dt2):
                 if not isinstance(dt1, datetime.datetime):
                     dt1 = datetime.datetime.fromordinal(dt1.toordinal())
@@ -195,7 +195,7 @@ Here is the behavior of operations with relativedelta:
                             self.day = yday-ydayidx[idx-1]
                         break
                 else:
-                    raise ValueError, "invalid year day (%d)" % yday
+                    raise ValueError("invalid year day (%d)" % yday)
 
         self._fix()
 
@@ -244,7 +244,7 @@ Here is the behavior of operations with relativedelta:
 
     def __radd__(self, other):
         if not isinstance(other, datetime.date):
-            raise TypeError, "unsupported type for add operation"
+            raise TypeError("unsupported type for add operation")
         elif self._has_time and not isinstance(other, datetime.datetime):
             other = datetime.datetime.fromordinal(other.toordinal())
         year = (self.year or other.year)+self.years
@@ -290,7 +290,7 @@ Here is the behavior of operations with relativedelta:
 
     def __add__(self, other):
         if not isinstance(other, relativedelta):
-            raise TypeError, "unsupported type for add operation"
+            raise TypeError("unsupported type for add operation")
         return relativedelta(years=other.years+self.years,
                              months=other.months+self.months,
                              days=other.days+self.days,
@@ -310,7 +310,7 @@ Here is the behavior of operations with relativedelta:
 
     def __sub__(self, other):
         if not isinstance(other, relativedelta):
-            raise TypeError, "unsupported type for sub operation"
+            raise TypeError("unsupported type for sub operation")
         return relativedelta(years=other.years-self.years,
                              months=other.months-self.months,
                              days=other.days-self.days,
@@ -427,7 +427,7 @@ Here is the behavior of operations with relativedelta:
                      "hour", "minute", "second", "microsecond"]:
             value = getattr(self, attr)
             if value is not None:
-                l.append("%s=%s" % (attr, `value`))
+                l.append("%s=%s" % (attr, repr(value)))
         return "%s(%s)" % (self.__class__.__name__, ", ".join(l))
 
 # vim:ts=4:sw=4:et
diff --git a/dateutil/rrule.py b/dateutil/rrule.py
index 6bd83ca..43ed46f 100644
--- a/dateutil/rrule.py
+++ b/dateutil/rrule.py
@@ -22,10 +22,10 @@ __all__ = ["rrule", "rruleset", "rrulestr",
 M366MASK = tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30+
                  [7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)
 M365MASK = list(M366MASK)
-M29, M30, M31 = range(1,30), range(1,31), range(1,32)
+M29, M30, M31 = list(range(1,30)), list(range(1,31)), list(range(1,32))
 MDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
 MDAY365MASK = list(MDAY366MASK)
-M29, M30, M31 = range(-29,0), range(-30,0), range(-31,0)
+M29, M30, M31 = list(range(-29,0)), list(range(-30,0)), list(range(-31,0))
 NMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
 NMDAY365MASK = list(NMDAY366MASK)
 M366RANGE = (0,31,60,91,121,152,182,213,244,274,305,335,366)
@@ -41,7 +41,7 @@ M365MASK = tuple(M365MASK)
  DAILY,
  HOURLY,
  MINUTELY,
- SECONDLY) = range(7)
+ SECONDLY) = list(range(7))
 
 # Imported on demand.
 easter = None
@@ -52,7 +52,7 @@ class weekday(object):
 
     def __init__(self, weekday, n=None):
         if n == 0:
-            raise ValueError, "Can't create weekday with n == 0"
+            raise ValueError("Can't create weekday with n == 0")
         self.weekday = weekday
         self.n = n
 
@@ -112,7 +112,7 @@ class rrulebase:
                     break
                 try:
                     for j in range(10):
-                        cache.append(gen.next())
+                        cache.append(next(gen))
                 except StopIteration:
                     self._cache_gen = gen = None
                     self._cache_complete = True
@@ -139,7 +139,7 @@ class rrulebase:
             gen = iter(self)
             try:
                 for i in range(item+1):
-                    res = gen.next()
+                    res = next(gen)
             except StopIteration:
                 raise IndexError
             return res
@@ -768,7 +768,7 @@ class _iterinfo(object):
         self.lastmonth = month
 
     def ydayset(self, year, month, day):
-        return range(self.yearlen), 0, self.yearlen
+        return list(range(self.yearlen)), 0, self.yearlen
 
     def mdayset(self, year, month, day):
         set = [None]*self.yearlen
@@ -839,8 +839,24 @@ class rruleset(rrulebase):
             except StopIteration:
                 self.genlist.remove(self)
 
-        def __cmp__(self, other):
-            return cmp(self.dt, other.dt)
+        def __eq__(self, other):
+            return self.dt == other.dt
+
+        def __ne__(self, other):
+            return self.dt != other.dt
+
+        def __lt__(self, other):
+            return self.dt < other.dt
+
+        def __le__(self, other):
+            return self.dt <= other.dt
+
+        def __gt__(self, other):
+            return self.dt > other.dt
+
+        def __ge__(self, other):
+            return self.dt >= other.dt
+
 
     def __init__(self, cache=False):
         rrulebase.__init__(self, cache)
@@ -880,13 +896,13 @@ class rruleset(rrulebase):
             ritem = rlist[0]
             if not lastdt or lastdt != ritem.dt:
                 while exlist and exlist[0] < ritem:
-                    exlist[0].next()
+                    next(exlist[0])
                     exlist.sort()
                 if not exlist or ritem != exlist[0]:
                     total += 1
                     yield ritem.dt
                 lastdt = ritem.dt
-            ritem.next()
+            next(ritem)
             rlist.sort()
         self._len = total
 
@@ -932,7 +948,7 @@ class _rrulestr:
                                            ignoretz=kwargs.get("ignoretz"),
                                            tzinfos=kwargs.get("tzinfos"))
         except ValueError:
-            raise ValueError, "invalid until date"
+            raise ValueError("invalid until date")
 
     def _handle_WKST(self, rrkwargs, name, value, **kwargs):
         rrkwargs["wkst"] = self._weekday_map[value]
@@ -959,7 +975,7 @@ class _rrulestr:
         if line.find(':') != -1:
             name, value = line.split(':')
             if name != "RRULE":
-                raise ValueError, "unknown parameter name"
+                raise ValueError("unknown parameter name")
         else:
             value = line
         rrkwargs = {}
@@ -972,9 +988,9 @@ class _rrulestr:
                                                ignoretz=ignoretz,
                                                tzinfos=tzinfos)
             except AttributeError:
-                raise ValueError, "unknown parameter '%s'" % name
+                raise ValueError("unknown parameter '%s'" % name)
             except (KeyError, ValueError):
-                raise ValueError, "invalid '%s': %s" % (name, value)
+                raise ValueError("invalid '%s': %s" % (name, value))
         return rrule(dtstart=dtstart, cache=cache, **rrkwargs)
 
     def _parse_rfc(self, s,
@@ -991,7 +1007,7 @@ class _rrulestr:
             unfold = True
         s = s.upper()
         if not s.strip():
-            raise ValueError, "empty string"
+            raise ValueError("empty string")
         if unfold:
             lines = s.splitlines()
             i = 0
@@ -1026,36 +1042,36 @@ class _rrulestr:
                     name, value = line.split(':', 1)
                 parms = name.split(';')
                 if not parms:
-                    raise ValueError, "empty property name"
+                    raise ValueError("empty property name")
                 name = parms[0]
                 parms = parms[1:]
                 if name == "RRULE":
                     for parm in parms:
-                        raise ValueError, "unsupported RRULE parm: "+parm
+                        raise ValueError("unsupported RRULE parm: "+parm)
                     rrulevals.append(value)
                 elif name == "RDATE":
                     for parm in parms:
                         if parm != "VALUE=DATE-TIME":
-                            raise ValueError, "unsupported RDATE parm: "+parm
+                            raise ValueError("unsupported RDATE parm: "+parm)
                     rdatevals.append(value)
                 elif name == "EXRULE":
                     for parm in parms:
-                        raise ValueError, "unsupported EXRULE parm: "+parm
+                        raise ValueError("unsupported EXRULE parm: "+parm)
                     exrulevals.append(value)
                 elif name == "EXDATE":
                     for parm in parms:
                         if parm != "VALUE=DATE-TIME":
-                            raise ValueError, "unsupported RDATE parm: "+parm
+                            raise ValueError("unsupported RDATE parm: "+parm)
                     exdatevals.append(value)
                 elif name == "DTSTART":
                     for parm in parms:
-                        raise ValueError, "unsupported DTSTART parm: "+parm
+                        raise ValueError("unsupported DTSTART parm: "+parm)
                     if not parser:
                         from dateutil import parser
                     dtstart = parser.parse(value, ignoretz=ignoretz,
                                            tzinfos=tzinfos)
                 else:
-                    raise ValueError, "unsupported property: "+name
+                    raise ValueError("unsupported property: "+name)
             if (forceset or len(rrulevals) > 1 or
                 rdatevals or exrulevals or exdatevals):
                 if not parser and (rdatevals or exdatevals):
diff --git a/dateutil/tz.py b/dateutil/tz.py
index 0e28d6b..a35cb31 100644
--- a/dateutil/tz.py
+++ b/dateutil/tz.py
@@ -75,7 +75,7 @@ class tzoffset(datetime.tzinfo):
 
     def __repr__(self):
         return "%s(%s, %s)" % (self.__class__.__name__,
-                               `self._name`,
+                               repr(self._name),
                                self._offset.days*86400+self._offset.seconds)
 
     __reduce__ = object.__reduce__
@@ -161,7 +161,7 @@ class _ttinfo(object):
         for attr in self.__slots__:
             value = getattr(self, attr)
             if value is not None:
-                l.append("%s=%s" % (attr, `value`))
+                l.append("%s=%s" % (attr, repr(value)))
         return "%s(%s)" % (self.__class__.__name__, ", ".join(l))
 
     def __eq__(self, other):
@@ -192,15 +192,18 @@ class tzfile(datetime.tzinfo):
 
     # http://www.twinsun.com/tz/tz-link.htm
     # ftp://elsie.nci.nih.gov/pub/tz*.tar.gz
-    
+   
+    MAGIC = b"TZif" if sys.version_info >= (3, 0) else "TZif"
+    ZEROBYTE = b"\x00" if sys.version_info >= (3, 0) else "\x00"
+
     def __init__(self, fileobj):
         if isinstance(fileobj, basestring):
             self._filename = fileobj
-            fileobj = open(fileobj)
+            fileobj = open(fileobj, mode='rb')
         elif hasattr(fileobj, "name"):
             self._filename = fileobj.name
         else:
-            self._filename = `fileobj`
+            self._filename = repr(fileobj)
 
         # From tzfile(5):
         #
@@ -212,8 +215,8 @@ class tzfile(datetime.tzinfo):
         # ``standard'' byte order (the high-order  byte
         # of the value is written first).
 
-        if fileobj.read(4) != "TZif":
-            raise ValueError, "magic not found"
+        if fileobj.read(4) != tzfile.MAGIC:
+            raise ValueError("magic not found")
 
         fileobj.read(16)
 
@@ -338,7 +341,7 @@ class tzfile(datetime.tzinfo):
             tti.offset = gmtoff
             tti.delta = datetime.timedelta(seconds=gmtoff)
             tti.isdst = isdst
-            tti.abbr = abbr[abbrind:abbr.find('\x00', abbrind)]
+            tti.abbr = abbr[abbrind:abbr.find(tzfile.ZEROBYTE, abbrind)]
             tti.isstd = (ttisstdcnt > i and isstd[i] != 0)
             tti.isgmt = (ttisgmtcnt > i and isgmt[i] != 0)
             self._ttinfo_list.append(tti)
@@ -451,7 +454,8 @@ class tzfile(datetime.tzinfo):
     def tzname(self, dt):
         if not self._ttinfo_std:
             return None
-        return self._find_ttinfo(dt).abbr
+        name = self._find_ttinfo(dt).abbr
+        return name.decode() if sys.version_info > (3, 0) else name
 
     def __eq__(self, other):
         if not isinstance(other, tzfile):
@@ -465,11 +469,11 @@ class tzfile(datetime.tzinfo):
 
 
     def __repr__(self):
-        return "%s(%s)" % (self.__class__.__name__, `self._filename`)
+        return "%s(%s)" % (self.__class__.__name__, repr(self._filename))
 
     def __reduce__(self):
         if not os.path.isfile(self._filename):
-            raise ValueError, "Unpickable %s class" % self.__class__.__name__
+            raise ValueError("Unpickable %s class" % self.__class__.__name__)
         return (self.__class__, (self._filename,))
 
 class tzrange(datetime.tzinfo):
@@ -561,7 +565,7 @@ class tzstr(tzrange):
 
         res = parser._parsetz(s)
         if res is None:
-            raise ValueError, "unknown string format"
+            raise ValueError("unknown string format")
 
         # Here we break the compatibility with the TZ variable handling.
         # GMT-3 actually *means* the timezone -3.
@@ -624,7 +628,7 @@ class tzstr(tzrange):
         return relativedelta.relativedelta(**kwargs)
 
     def __repr__(self):
-        return "%s(%s)" % (self.__class__.__name__, `self._s`)
+        return "%s(%s)" % (self.__class__.__name__, repr(self._s))
 
 class _tzicalvtzcomp:
     def __init__(self, tzoffsetfrom, tzoffsetto, isdst,
@@ -694,7 +698,7 @@ class _tzicalvtz(datetime.tzinfo):
         return self._find_comp(dt).tzname
 
     def __repr__(self):
-        return "<tzicalvtz %s>" % `self._tzid`
+        return "<tzicalvtz %s>" % repr(self._tzid)
 
     __reduce__ = object.__reduce__
 
@@ -710,29 +714,29 @@ class tzical:
         elif hasattr(fileobj, "name"):
             self._s = fileobj.name
         else:
-            self._s = `fileobj`
+            self._s = repr(fileobj)
 
         self._vtz = {}
 
         self._parse_rfc(fileobj.read())
 
     def keys(self):
-        return self._vtz.keys()
+        return list(self._vtz.keys())
 
     def get(self, tzid=None):
         if tzid is None:
-            keys = self._vtz.keys()
+            keys = list(self._vtz.keys())
             if len(keys) == 0:
-                raise ValueError, "no timezones defined"
+                raise ValueError("no timezones defined")
             elif len(keys) > 1:
-                raise ValueError, "more than one timezone available"
+                raise ValueError("more than one timezone available")
             tzid = keys[0]
         return self._vtz.get(tzid)
 
     def _parse_offset(self, s):
         s = s.strip()
         if not s:
-            raise ValueError, "empty offset"
+            raise ValueError("empty offset")
         if s[0] in ('+', '-'):
             signal = (-1,+1)[s[0]=='+']
             s = s[1:]
@@ -743,12 +747,12 @@ class tzical:
         elif len(s) == 6:
             return (int(s[:2])*3600+int(s[2:4])*60+int(s[4:]))*signal
         else:
-            raise ValueError, "invalid offset: "+s
+            raise ValueError("invalid offset: "+s)
 
     def _parse_rfc(self, s):
         lines = s.splitlines()
         if not lines:
-            raise ValueError, "empty string"
+            raise ValueError("empty string")
 
         # Unfold
         i = 0
@@ -772,7 +776,7 @@ class tzical:
             name, value = line.split(':', 1)
             parms = name.split(';')
             if not parms:
-                raise ValueError, "empty property name"
+                raise ValueError("empty property name")
             name = parms[0].upper()
             parms = parms[1:]
             if invtz:
@@ -781,7 +785,7 @@ class tzical:
                         # Process component
                         pass
                     else:
-                        raise ValueError, "unknown component: "+value
+                        raise ValueError("unknown component: "+value)
                     comptype = value
                     founddtstart = False
                     tzoffsetfrom = None
@@ -791,27 +795,21 @@ class tzical:
                 elif name == "END":
                     if value == "VTIMEZONE":
                         if comptype:
-                            raise ValueError, \
-                                  "component not closed: "+comptype
+                            raise ValueError("component not closed: "+comptype)
                         if not tzid:
-                            raise ValueError, \
-                                  "mandatory TZID not found"
+                            raise ValueError("mandatory TZID not found")
                         if not comps:
-                            raise ValueError, \
-                                  "at least one component is needed"
+                            raise ValueError("at least one component is needed")
                         # Process vtimezone
                         self._vtz[tzid] = _tzicalvtz(tzid, comps)
                         invtz = False
                     elif value == comptype:
                         if not founddtstart:
-                            raise ValueError, \
-                                  "mandatory DTSTART not found"
+                            raise ValueError("mandatory DTSTART not found")
                         if tzoffsetfrom is None:
-                            raise ValueError, \
-                                  "mandatory TZOFFSETFROM not found"
+                            raise ValueError("mandatory TZOFFSETFROM not found")
                         if tzoffsetto is None:
-                            raise ValueError, \
-                                  "mandatory TZOFFSETFROM not found"
+                            raise ValueError("mandatory TZOFFSETFROM not found")
                         # Process component
                         rr = None
                         if rrulelines:
@@ -825,8 +823,7 @@ class tzical:
                         comps.append(comp)
                         comptype = None
                     else:
-                        raise ValueError, \
-                              "invalid component end: "+value
+                        raise ValueError("invalid component end: "+value)
                 elif comptype:
                     if name == "DTSTART":
                         rrulelines.append(line)
@@ -835,40 +832,36 @@ class tzical:
                         rrulelines.append(line)
                     elif name == "TZOFFSETFROM":
                         if parms:
-                            raise ValueError, \
-                                  "unsupported %s parm: %s "%(name, parms[0])
+                            raise ValueError("unsupported %s parm: %s "%(name, parms[0]))
                         tzoffsetfrom = self._parse_offset(value)
                     elif name == "TZOFFSETTO":
                         if parms:
-                            raise ValueError, \
-                                  "unsupported TZOFFSETTO parm: "+parms[0]
+                            raise ValueError("unsupported TZOFFSETTO parm: "+parms[0])
                         tzoffsetto = self._parse_offset(value)
                     elif name == "TZNAME":
                         if parms:
-                            raise ValueError, \
-                                  "unsupported TZNAME parm: "+parms[0]
+                            raise ValueError("unsupported TZNAME parm: "+parms[0])
                         tzname = value
                     elif name == "COMMENT":
                         pass
                     else:
-                        raise ValueError, "unsupported property: "+name
+                        raise ValueError("unsupported property: "+name)
                 else:
                     if name == "TZID":
                         if parms:
-                            raise ValueError, \
-                                  "unsupported TZID parm: "+parms[0]
+                            raise ValueError("unsupported TZID parm: "+parms[0])
                         tzid = value
                     elif name in ("TZURL", "LAST-MODIFIED", "COMMENT"):
                         pass
                     else:
-                        raise ValueError, "unsupported property: "+name
+                        raise ValueError("unsupported property: "+name)
             elif name == "BEGIN" and value == "VTIMEZONE":
                 tzid = None
                 comps = []
                 invtz = True
 
     def __repr__(self):
-        return "%s(%s)" % (self.__class__.__name__, `self._s`)
+        return "%s(%s)" % (self.__class__.__name__, repr(self._s))
 
 if sys.platform != "win32":
     TZFILES = ["/etc/localtime", "localtime"]
diff --git a/example.py b/example.py
index 0a1ef7c..6ff0b1b 100644
--- a/example.py
+++ b/example.py
@@ -3,9 +3,9 @@ from dateutil.easter import *
 from dateutil.rrule import *
 from dateutil.parser import *
 from datetime import *
-import commands
+import subprocess
 import os
-now = parse(commands.getoutput("LC_ALL=C date"))
+now = parse(subprocess.getoutput("LC_ALL=C date"))
 today = now.date()
 year = rrule(YEARLY,bymonth=8,bymonthday=13,byweekday=FR)[0].year
 rdelta = relativedelta(easter(year), today)
diff --git a/setup.py b/setup.py
index 654ab46..1b95986 100755
--- a/setup.py
+++ b/setup.py
@@ -6,6 +6,10 @@ import re
 
 from setuptools import setup
 
+try:
+    from distutils.command.build_py import build_py_2to3 as build_py
+except ImportError:
+    from distutils.command.build_py import build_py
 
 if isfile("MANIFEST"):
     os.unlink("MANIFEST")
@@ -32,4 +36,5 @@ datetime module, available in Python 2.3+.
       package_data={"": ["*.tar.gz"]},
       include_package_data=True,
       zip_safe=False,
+      cmdclass={'build_py': build_py}
       )
diff --git a/test.py b/test.py
index 049fede..cd0abd6 100755
--- a/test.py
+++ b/test.py
@@ -6,11 +6,16 @@ import calendar
 import time
 import base64
 import os
+import sys
+
+try:
+    from io import BytesIO
+except ImportError:
+    pass
 
 # Add build directory to search path
 if os.path.exists("build"):
 	from distutils.util import get_platform
-	import sys
 	s = "build/lib.%s-%.3s" % (get_platform(), sys.version)
 	s = os.path.join(os.getcwd(), s)
 	sys.path.insert(0,s)
@@ -3874,12 +3879,20 @@ END:VTIMEZONE
                          tzrange("EST", -18000, "EDT"))
 
     def testFileStart1(self):
-        tz = tzfile(StringIO(base64.decodestring(self.TZFILE_EST5EDT)))
+        if sys.version_info >= (3, 0):
+            tzdata = BytesIO(base64.decodebytes(self.TZFILE_EST5EDT.encode()))
+        else:
+            tzdata = StringIO(base64.decodestring(self.TZFILE_EST5EDT))
+        tz = tzfile(tzdata)
         self.assertEqual(datetime(2003,4,6,1,59,tzinfo=tz).tzname(), "EST")
         self.assertEqual(datetime(2003,4,6,2,00,tzinfo=tz).tzname(), "EDT")
         
     def testFileEnd1(self):
-        tz = tzfile(StringIO(base64.decodestring(self.TZFILE_EST5EDT)))
+        if sys.version_info >= (3, 0):
+            tzdata = BytesIO(base64.decodebytes(self.TZFILE_EST5EDT.encode()))
+        else:
+            tzdata = StringIO(base64.decodestring(self.TZFILE_EST5EDT))
+        tz = tzfile(tzdata)
         self.assertEqual(datetime(2003,10,26,0,59,tzinfo=tz).tzname(), "EDT")
         self.assertEqual(datetime(2003,10,26,1,00,tzinfo=tz).tzname(), "EST")
 
@@ -3914,14 +3927,22 @@ END:VTIMEZONE
 
     def testRoundNonFullMinutes(self):
         # This timezone has an offset of 5992 seconds in 1900-01-01.
-        tz = tzfile(StringIO(base64.decodestring(self.EUROPE_HELSINKI)))
+        if sys.version_info >= (3, 0):
+            tzdata = BytesIO(base64.decodebytes(self.EUROPE_HELSINKI.encode()))
+        else:
+            tzdata = StringIO(base64.decodestring(self.EUROPE_HELSINKI))
+        tz = tzfile(tzdata)
         self.assertEquals(str(datetime(1900,1,1,0,0, tzinfo=tz)),
                           "1900-01-01 00:00:00+01:40")
 
     def testLeapCountDecodesProperly(self):
         # This timezone has leapcnt, and failed to decode until
         # Eugene Oden notified about the issue.
-        tz = tzfile(StringIO(base64.decodestring(self.NEW_YORK)))
+        if sys.version_info >= (3, 0):
+            tzdata = BytesIO(base64.decodebytes(self.NEW_YORK.encode()))
+        else:
+            tzdata = StringIO(base64.decodestring(self.NEW_YORK))
+        tz = tzfile(tzdata)
         self.assertEquals(datetime(2007,3,31,20,12).tzname(), None)
 
     def testBrokenIsDstHandling(self):
-- 
1.7.3.4

