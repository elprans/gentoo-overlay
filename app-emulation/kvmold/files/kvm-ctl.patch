diff --git a/qemu/Makefile b/qemu/Makefile
index d45cfaf..d090ff6 100644
--- a/qemu/Makefile
+++ b/qemu/Makefile
@@ -172,6 +172,8 @@ bt-host.o: bt-host.c
 audio/sdlaudio.o: audio/sdlaudio.c
 	$(CC) $(CFLAGS) $(CPPFLAGS) $(SDL_CFLAGS) -c -o $@ $<
 
+qemu-ctl.o: qemu-ctl.c
+
 libqemu_common.a: $(OBJS)
 	rm -f $@ 
 	$(AR) rcs $@ $(OBJS)
@@ -199,6 +201,8 @@ qemu-nbd$(EXESUF):  qemu-nbd.o qemu-tool.o osdep.o $(BLOCK_OBJS)
 dyngen$(EXESUF): dyngen.c
 	$(HOST_CC) $(CFLAGS) $(CPPFLAGS) -o $@ $^
 
+qemu-ctl$(EXESUF): qemu-ctl.o
+
 clean:
 # avoid old build problems by removing potentially incorrect old files
 	rm -f config.mak config.h op-i386.h opc-i386.h gen-op-i386.h op-arm.h opc-arm.h gen-op-arm.h
diff --git a/qemu/configure b/qemu/configure
index de30a95..6292528 100755
--- a/qemu/configure
+++ b/qemu/configure
@@ -1475,6 +1475,7 @@ if test `expr "$target_list" : ".*softmmu.*"` != 0 ; then
       tools="qemu-nbd\$(EXESUF) $tools"
   fi
 fi
+tools="qemu-ctl\$(EXESUF) $tools"
 echo "TOOLS=$tools" >> $config_mak
 
 test -f ${config_h}~ && cmp -s $config_h ${config_h}~ && mv ${config_h}~ $config_h
diff --git a/qemu/qemu-ctl.c b/qemu/qemu-ctl.c
new file mode 100644
index 0000000..86d8c79
--- /dev/null
+++ b/qemu/qemu-ctl.c
@@ -0,0 +1,104 @@
+#include <fcntl.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+const char *prompt = "(qemu) ";
+
+void echo(char *s, size_t n, int *skip) {
+  char *p;
+
+  for (p = s; *skip != 0 && p < n + s; p++, (*skip)--)
+    if ((p = memchr(p, '\n', n + s - p)) == NULL)
+      return;
+
+  if (p < n + s)
+    write(STDOUT_FILENO, p, n + s - p);
+}
+
+void getprompt(int fd, int skip, int eof) {
+  char s[PIPE_BUF];
+  int n, sl = 0;
+
+  do {
+    if ((n = read(fd, s + sl, sizeof(s) - sl)) < 0) {
+      perror("read");
+      exit(EXIT_FAILURE);
+    } else
+      sl += n;
+
+    if (n == 0) {
+      echo(s, sl, &skip);
+      exit(eof);
+    }
+
+    if (sl > strlen(prompt)) {
+      echo(s, sl - strlen(prompt), &skip);
+      memmove(s, s + sl - strlen(prompt), strlen(prompt));
+      sl = strlen(prompt);
+    }
+  } while (memcmp(s, prompt, strlen(prompt)));
+}
+
+void usage(char *progname) {
+  fprintf(stderr, "\
+Usage: %1$s [-n] [-q] SOCKET COMMAND\n\
+       %1$s -t SOCKET\n\
+Options:\n\
+  -n    do not wait for command to finish before returning\n\
+  -q    do not echo output from kvm/qemu to stdout\n\
+  -t    test if kvm/qemu is listening on SOCKET without issuing a command\n\
+", progname);
+  exit(EXIT_FAILURE);
+}
+
+int main(int argc, char **argv) {
+  int n, sock, quiet = 0, wait = 1, test = 0;
+  struct sockaddr_un sockaddr;
+
+  while ((n = getopt(argc, argv, "nqt")) > 0)
+    switch (n) {
+      case 'n':
+        wait = 0;
+        break;
+      case 'q':
+        quiet = 1;
+        break;
+      case 't':
+        test = 1;
+        break;
+      default:
+        usage(argv[0]);
+    }
+  if ((argc -= optind) != (test ? 1 : 2))
+    usage(argv[0]);
+  argv += optind;
+
+  if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
+    perror("socket");
+    return EXIT_FAILURE;
+  }
+
+  sockaddr.sun_family = AF_UNIX;
+  strcpy(sockaddr.sun_path, argv[0]);
+  n = strlen(sockaddr.sun_path) + sizeof(sockaddr.sun_family);
+  if (connect(sock, (struct sockaddr *) &sockaddr, n) < 0) {
+    if (test == 0)
+      perror("connect");
+    return EXIT_FAILURE;
+  }
+
+  getprompt(sock, -1, EXIT_FAILURE);
+  if (test == 0) {
+    write(sock, argv[1], strlen(argv[1]));
+    write(sock, "\n", 1);
+    if (wait)
+      /* always discard first line because of command echo */
+      getprompt(sock, quiet ? -1 : 1, EXIT_SUCCESS);
+  }
+  return EXIT_SUCCESS;
+}
+
